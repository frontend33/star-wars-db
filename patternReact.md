**Render функция**
>Паттерн React - в компоненте передается функция, которая рендерит часть компонента (или весь компонент)
```` >Card renderBody = {() => <p>hello </p>} /> ````

>Такая функция обычно возвращает строку или React элемент
 В родителе app.js объявлеяем рендер функцию ````renderItem={(item) => item.name}```` и в зависимости от компонента мы можем менять, что отображать пользователю внутри компонента не повторяя наш код множество раз, внутри отрисовки списка элементов item-list объявляем функцию
 ```` const label = this.props.renderItem(item) ````
 и в цикле передаем аргумент нашего item
Вывод: Рендер функция это паттерн React когда вы передаете в функцию компонент которая занимается рендерингом части компонента или всего компонента

#### В родителе объявлеяем рендер функцию
```
<div className="col-md-6">
        <ItemList OnItemSelected={this.OnPersonSelected} 
            getData={this.swapiService.getAllStarships}
            renderItem={(item) => item.name}
              
        />
</div>
```
#### В дочернем компоненте получаем пропсы родителя и передаем их в цикл для отрисовки элемента
```
renderItems(arr) {
    return arr.map((item) => {
        const { id } = item
        const label = this.props.renderItem(item)
        return (
            <li className="list-group-item"
                key={id}
                // При клике на компонент передаем его id родителю для детального просмотра
                onClick={() => this.props.onItemSelected(id)}>
                    {/* Передадим функцию что бы отображать разные условия item list */}
                {/* {name} */}
                {label}

            </li>
        )
    })
}
render() {
    const { itemList } = this.state
    if (!itemList) {
        return <Spinner />
    }

    const items = this.renderItems(itemList)
    return (
        <ul className="item-list item-list-group" >
            {items}
        </ul>
    )
}

}
```

**Свойста-элементы**
> В качестве значения свойства можно передавать React элемент
````<Card title={<h1>Hi</h1>} />````
> Так можно создавать элементы контейнеры или элементы которые умеют выбирать, что рендерить в зависимости от условия (загрузка, ошибка и т п)
За классом, создаем переменную Row передаем в нее параметры
далее можем передавать значения в компонент
```
const Row = ({ left, right }) => {
    return (
        <div className="row mb2">
            <div className="col-md-6">
                {left}
            </div>
            <div className="col-md-6">
                {right}
            </div>
        </div>
    )
}
```

```
 return (
            <div>
                <Row left={itemList} right={personDetails} />
                <Row left={<p>Hello</p>} right="Bar" />
            </div>
        );
```

**Children**
В реакт есть два способа передавать свойства компонентам
1)Способ
```
onItemSelected={this.onPersonSelected}
```
2)Способ передать свойства прямо в тело тега который описывает компонент
Компоненту можно передавать одно из свойств поместив его в тело элемента
<Card> How are you</Card>
Это свойство доступно через props.children
Поддерживает любые типы данных элементы функции объекты и другие

React элементы нельзя изменять после того как они были созданы, мы должны работать с элементами так будто они не изменяемы, 

```
    React.Children.map(this.props.children, (child) => {
        cloneElement принимает несколько аргументов (элемент который нужно скопировать, второй аргумент добавить еще свойств к этому элементу)
        return React.cloneElement(child, { item });
    })
    
    const Record = ({ item, field, label }) => {
    return (
        <li className="list-group-item">
        <span className="term">{label}</span>
        // и можем в record передать  item[field]
        <span>{ item[field] }</span>
        </li>
    );
    };
```
**Клонирование элементов**
React элементы нельзя изменять (они считаются immutable)
Но можно создвавать модифицированные копии при помощи React.cloneElement()
К примеру элементам можно добавлять новые свойства

**higher order component Компонент высшего порядка**
Создаем функцию которая возвращает компонент - который оборачивает основной компонент, и этот компонент обертка может взять на себя обязанности о которых не нужно заботиться внутреннему компоненту в случае с hoc-helper мы берем обязанности на компонент отображать данные, отрисовывать спиннер отображать компонент с ошибкой
Можно использовать не только с данными но и с любыми аспектами приложения, которые будет полезно вынести наружу, которые будет полезно вынести наружу, которые будет полезно отделить от основного компонента и переиспользовать не переписыая код 
Вывод: Компонент высшего порядка

```
const hoc = (Wrapped) => {
    return class extends Component {
        render () {
            return <Wrapped {...this.props}>
        }
    }
}
const MyWrappedComponent = hoc(InnerComponent)
Функция которая создает компоненты и оборачивает существующие

```

**Рефакторинг компонентов**
Обратная сторона гибкости компонентов это громоздкая конфигурация
Код будет более читабельным, если вынести детали конфигурации в отдельные компоненты
Для этого можно использовать НОС (компоненты высшего порядка ) или просто написать компонент обертку вручную

**Композиция компонентов высшего порядка**
Композиция применение одной функции к результату другой: f(g(x))
Компоненты высшего порядка это обычные функции, которые возвращают компоненты.
Композиция работает и для них.
Так мы можем применять несколько эффектов HOC - Higher Order Component

**Контекст CONTEXT**
Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.

 Контекст нужен для того чтобы решить проблему глобальных данных.
 Вместо того, чтобы передавать props через все слои приложения данные можно передавать через контекст.
 С помощью контекста мы сможем сделать так, чтобы компоненты не создавали объекты сервиса, а получали его

Контекст позволяет создать специальное хранилище данных и данные которые мы запишем в хранилище 
будут доступны всем компонентам иерархии без необходимости явно передавать данные через свойства.
Создавая контекст мы создаем, два специальных компонента 


1)Provider - Отвечает за то что бы установить значение которое можно будет использовать в иерархии 

2) Consumer Второй компонент используется для того что бы считать значение 


Таким образом при помощи api context можно передавать значения с самого вверха иерархии приложения к любому компоненту ниже по иерархии,
но при этом промежуточные компоненты ничего не обязаны знать про значение которое мы передаем
 ```
 <App>
    <Provider value={lang}>
        <HomePage>
            <div>
                <new>
                </new>
            </div>
        </HomePage>
        <SupportPage>
            <div>
            <Consumer>
                {
    // В эту функцию компонент Consumer сможет передать, то значение которое он получит от ближайшего компонента 
    в нашем случае значение lang из Provider 
                    (lang) => {
                        return (
                            //Здесь можно вернуть те компоненты которые зависят от lang
                            <Chat lang={lang}>
                            </Chat>
                        )
                    }
                }
            </Consumer>
            </div>
        </SupportPage>
    </Provider>
 </App>


```
**API CONTEXT** 
Позволяет решать нам проблему глобальных данных, передавать какие то значения до любых компонентов ниже по иерархии, не передавая свойства в явном виде 
 ```
// Создадим контекст
const { Provider, Consumer } = React.createService()
<Provider value={someValue}>
// Провайдер оборачивает часть приложения
</Provider>

<Consumer>
    {
        (someValue) => <MyComponent data = {someValue}></MyComponent>
    }
</Consumer>

```
**Трансформация props в компонентах высшего порядка**
HOC может переобразовывать свойства перед тем, как передавать их компоненту
Например, изменять их имена и выбирать, какие именно свойства нужно передать
При помощи дополнительной функции (mapMethodsToProps) можно определять это поведение для каждого компонента

**Обновление контекста**
Значение в контексте можно обновлять, как любое другое свойство компонента
Компоненты должны поддерживать изменение нужных свойств
componentDidUpdate() функция в которой можно проверить, какие свойства изменились
**Рефакторинг HOC**
Техника которую мы использовали в item-lists, with-swapi-service.js и persondetails.js planetdetails.js, starshipdetails.js называются частично примененные функции (partially applied functions)

const add = (a) => (b) => a + b 
Такие функции принимают часть аргументов и возвращают новые функции с меньшим количеством аргументов

**Функция compose**
Реализует композицию в виде функции

compose = (...func) => (comp) => {
    return funcs.reduceRight (
        (wrapped, f) => f(wrapped), comp)
    )
}

const MyComp = compose (
    withService,
    withData,
    withChild(renderName)
)(SimpleComponent)