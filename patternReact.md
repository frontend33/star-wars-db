**Render функция**
>Паттерн React - в компоненте передается функция, которая рендерит часть компонента (или весь компонент)
```` >Card renderBody = {() => <p>hello </p>} /> ````

>Такая функция обычно возвращает строку или React элемент
 В родителе app.js объявлеяем рендер функцию ````renderItem={(item) => item.name}```` и в зависимости от компонента мы можем менять, что отображать пользователю внутри компонента не повторяя наш код множество раз, внутри отрисовки списка элементов item-list объявляем функцию
 ```` const label = this.props.renderItem(item) ````
 и в цикле передаем аргумент нашего item
Вывод: Рендер функция это паттерн React когда вы передаете в функцию компонент которая занимается рендерингом части компонента или всего компонента

#### В родителе объявлеяем рендер функцию
```
<div className="col-md-6">
        <ItemList OnItemSelected={this.OnPersonSelected} 
            getData={this.swapiService.getAllStarships}
            renderItem={(item) => item.name}
              
        />
</div>
```
#### В дочернем компоненте получаем пропсы родителя и передаем их в цикл для отрисовки элемента
```
renderItems(arr) {
    return arr.map((item) => {
        const { id } = item
        const label = this.props.renderItem(item)
        return (
            <li className="list-group-item"
                key={id}
                // При клике на компонент передаем его id родителю для детального просмотра
                onClick={() => this.props.onItemSelected(id)}>
                    {/* Передадим функцию что бы отображать разные условия item list */}
                {/* {name} */}
                {label}

            </li>
        )
    })
}
render() {
    const { itemList } = this.state
    if (!itemList) {
        return <Spinner />
    }

    const items = this.renderItems(itemList)
    return (
        <ul className="item-list item-list-group" >
            {items}
        </ul>
    )
}

}
```

**Свойста-элементы**
> В качестве значения свойства можно передавать React элемент
````<Card title={<h1>Hi</h1>} />````
> Так можно создавать элементы контейнеры или элементы которые умеют выбирать, что рендерить в зависимости от условия (загрузка, ошибка и т п)
За классом, создаем переменную Row передаем в нее параметры
далее можем передавать значения в компонент
```
const Row = ({ left, right }) => {
    return (
        <div className="row mb2">
            <div className="col-md-6">
                {left}
            </div>
            <div className="col-md-6">
                {right}
            </div>
        </div>
    )
}
```

```
 return (
            <div>
                <Row left={itemList} right={personDetails} />
                <Row left={<p>Hello</p>} right="Bar" />
            </div>
        );
```

**Children**
В реакт есть два способа передавать свойства компонентам
1)Способ
```
onItemSelected={this.onPersonSelected}
```
2)Способ передать свойства прямо в тело тега который описывает компонент
Компоненту можно передавать одно из свойств поместив его в тело элемента
<Card> How are you</Card>
Это свойство доступно через props.children
Поддерживает любые типы данных элементы функции объекты и другие

React элементы нельзя изменять после того как они были созданы, мы должны работать с элементами так будто они не изменяемы, 

```
    React.Children.map(this.props.children, (child) => {
        cloneElement принимает несколько аргументов (элемент который нужно скопировать, второй аргумент добавить еще свойств к этому элементу)
        return React.cloneElement(child, { item });
    })
    
    const Record = ({ item, field, label }) => {
    return (
        <li className="list-group-item">
        <span className="term">{label}</span>
        // и можем в record передать  item[field]
        <span>{ item[field] }</span>
        </li>
    );
    };
```
**Клонирование элементов**
React элементы нельзя изменять (они считаются immutable)
Но можно создвавать модифицированные копии при помощи React.cloneElement()
К примеру элементам можно добавлять новые свойства

**higher order component Компонент высшего порядка**
Создаем функцию которая возвращает компонент - который оборачивает основной компонент, и этот компонент обертка может взять на себя обязанности о которых не нужно заботиться внутреннему компоненту в случае с hoc-helper мы берем обязанности на компонент отображать данные, отрисовывать спиннер отображать компонент с ошибкой
Можно использовать не только с данными но и с любыми аспектами приложения, которые будет полезно вынести наружу, которые будет полезно вынести наружу, которые будет полезно отделить от основного компонента и переиспользовать не переписыая код 
Вывод: Компонент высшего порядка

```
const hoc = (Wrapped) => {
    return class extends Component {
        render () {
            return <Wrapped {...this.props}>
        }
    }
}
const MyWrappedComponent = hoc(InnerComponent)
Функция которая создает компоненты и оборачивает существующие

```

**Рефакторинг компонентов**
Обратная сторона гибкости компонентов это громоздкая конфигурация
Код будет более читабельным, если вынести детали конфигурации в отдельные компоненты
Для этого можно использовать НОС (компоненты высшего порядка ) или просто написать компонент обертку вручную